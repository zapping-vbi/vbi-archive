<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.0 transitional//EN">

<html>
  <head>
    <meta name="generator" content="HTML Tidy, see www.w3.org">
<style type="text/css">
    BODY { font-family: times; }
    TT { font-weight: bold; }
  
</style>

    <title>Zapping documentation: Regular expressions</title>
  </head>

  <body color="#000000" bgcolor="#fffefe">
    <center>
      <h1>Unicode and Regular Expressions</h1>

      <h2>Version 0.5</h2>
    </center>

    <h3><a name="Contents"></a>Contents</h3>

    <ul>
      <li><a href="#Foreword">Foreword</a></li>

      <li><a href="#Introduction">Introduction</a></li>

      <li><a href="#Formal description">Formal description</a></li>
    </ul>
    Credits are due to 

    <ul>
      <li>Mark Leishner and his wonderful URE package which
      contributed most of Zapping's Unicode regex code. You can
      find it at <a href=
      "http://crl.nmsu.edu/~mleisher/">http://crl.nmsu.edu/~mleisher/</a>.
      But please direct any comments or bugs to <a href=
      "mailto:garetxe@users.sourceforge.net">me</a> instead,
      please.</li>

      <li>the Emacs documentation team for the regular expression
      introduction below. Emacs is available from <a href=
      "http://www.gnu.org">http://www.gnu.org</a>.</li>
    </ul>

    <h3><a name="Foreword"></a>Foreword</h3>
    Regular expressions are a powerful way to search certain
    patterns in a text. Apart of simply giving the text you want to
    find, you can build a set of rules to be matched, this allows
    for a much more powerful search. [FIXME: Zapping... Unicode...]
    

    <h3><a name="Introduction">Introduction</a></h3>
    Regular expressions have a syntax in which a few characters are
    special constructs and the rest are "ordinary". An ordinary
    character is a simple regular expression which matches that
    same character and nothing else. The special characters are
    <tt>$</tt>, <tt>^</tt>, <tt>.</tt>, <tt>*</tt>, <tt>+</tt>,
    <tt>?</tt>, <tt>[</tt>, <tt>]</tt> and <tt>\</tt>. Any other
    character appearing in a regular expression is ordinary, unless
    a <tt>\</tt> precedes it. 

    <p>For example, <tt>f</tt> is not a special character, so it is
    ordinary, and therefore <tt>f</tt> is a regular expression that
    matches the string "f" and no other string. (It does <i>not</i>
    match the string "ff".) Likewise, <tt>o</tt> is a regular
    expression that matches only "o". (When case distinctions are
    being ignored, these regexps also match "F" and "O", but we
    consider this a generalization of "the same string," rather
    than an exception.)</p>

    <p>Any two regular expressions A and B can be concatenated. The
    result is a regular expression which matches a string if A
    matches some amount of the beginning of that string and B
    matches the rest of the string.</p>

    <p>As a simple example, we can concatenate the regular
    expressions <tt>f</tt> and <tt>o</tt> to get the regular
    expression <tt>fo</tt>, which matches only the string "fo".
    Still trivial. To do something nontrivial, you need to use one
    of the special characters. Here is a list of them.</p>

    <dl>
      <dt><tt>.</tt> (Period)</dt>

      <dd>is a special character that matches any single character
      except a newline. Using concatenation, we can make regular
      expressions like <tt>a.b</tt>, which matches any
      three-character string that begins with "a" and ends with
      "b".<br>
      <br>
      </dd>

      <dt><tt>*</tt></dt>

      <dd>
        is not a construct by itself; it is a postfix operator that
        means to match the preceding regular expression
        repetitively as many times as possible. Thus, <tt>o*</tt>
        matches any number of "o"s (including no "o"s). 

        <p><tt>*</tt> always applies to the <i>smallest</i>
        possible preceding expression. Thus, <tt>fo*</tt> has a
        repeating <tt>o</tt>, not a repeating <tt>fo</tt>. It
        matches "f", "fo", "foo", and so on.</p>

        <p>The matcher processes a <tt>*</tt> construct by
        matching, immediately, as many repetitions as can be found.
        Then it continues with the rest of the pattern. If that
        fails, backtracking occurs, discarding some of the matches
        of the <tt>*</tt>-modified construct in case that makes it
        possible to match the rest of the pattern. For example, in
        matching <tt>ca*ar</tt> against the string "caaar", the
        <tt>a*</tt> first tries to match all three "a"s; but the
        rest of the pattern is <tt>ar</tt> and there is only "r"
        left to match, so this try fails. The next alternative is
        for <tt>a*</tt> to match only two "a"s. With this choice,
        the rest of the regexp matches successfully.</p>
      </dd>

      <dt><tt>+</tt></dt>

      <dd>is a postfix operator, similar to <tt>*</tt> except that
      it must match the preceding expression at least once. So, for
      example, <tt>ca+r</tt> matches the strings "car" and "caaaar"
      but not the string "cr", whereas <tt>ca*r</tt> matches all
      three strings.<br>
      <br>
      </dd>

      <dt><tt>?</tt></dt>

      <dd>is a postfix operator, similar to <tt>*</tt> except that
      it can match the preceding expression either once or not at
      all. For example, <tt>ca?r</tt> matches "car" or "cr";
      nothing else.<br>
      <br>
      </dd>

      <dt><tt>[ ... ]</tt></dt>

      <dd>
        is a "character set", which begins with <tt>[</tt> and is
        terminated by <tt>]</tt>. In the simplest case, the
        characters between the two brackets are what this set can
        match. 

        <p>Thus, <tt>[ad]</tt> matches either one "a" or one "d",
        and <tt>[ad]*</tt> matches any string composed of just "a"s
        and "d"s (including the empty string), from which it
        follows that <tt>c[ad]*r</tt> matches "cr", "car", "cdr",
        "caddaar", etc.</p>

        <p>You can also include character ranges in a character
        set, by writing the starting and ending characters with a
        <tt>-</tt> between them. Thus, <tt>[a-z]</tt> matches any
        lower-case ASCII letter. Ranges may be intermixed freely
        with individual characters, as in <tt>[a-z$%.]</tt>, which
        matches any lower-case ASCII letter or "$", "%" or
        period.</p>

        <p>Note that the usual regexp special characters are not
        special inside a character set. A completely different set
        of special characters exists inside character sets:
        <tt>]</tt>, <tt>-</tt> and <tt>^</tt>.</p>

        <p>To include a <tt>]</tt> in a character set, you must
        make it the first character. For example, <tt>[]a]</tt>
        matches "]" or "a". To include a <tt>-</tt>, write
        <tt>-</tt> as the first or last character of the set, or
        put it after a range. Thus, <tt>[]-]</tt> matches both "]"
        and "-".</p>

        <p>To include <tt>^</tt> in a set, put it anywhere but at
        the beginning of the set.</p>

        <p>When you use a range in case-insensitive search, you
        should write both ends of the range in upper case, or both
        in lower case, or both should be non-letters.</p>
      </dd>

      <dt><tt>[^ ... ]</tt></dt>

      <dd><tt>[^</tt> begins a "complemented character set", which
      matches any character except the ones specified. Thus,
      <tt>[^a-z0-9A-Z]</tt> matches all characters <i>except</i>
      letters and digits. <tt>^</tt> is not special in a character
      set unless it is the first character. The character following
      the <tt>^</tt> is treated as if it were first (in other
      words, <tt>-</tt> and <tt>]</tt> are not special there).<br>
      <br>
      </dd>

      <dt><tt>^</tt></dt>

      <dd>is a special character that matches the empty string, but
      only at the beginning of a line in the text being matched.
      Otherwise it fails to match anything. Thus, <tt>^foo</tt>
      matches a "foo" that occurs at the beginning of a line.<br>
      <br>
      </dd>

      <dt><tt>$</tt></dt>

      <dd>is similar to <tt>^</tt> but matches only at the end of a
      line. Thus, <tt>x+$</tt> matches a string of one "x" or more
      at the end of a line.<br>
      <br>
      </dd>

      <dt><tt>\</tt></dt>

      <dd>
        has two functions: it quotes the special characters
        (including <tt>\</tt>), and it introduces additional
        special constructs. 

        <p>Because <tt>\</tt> quotes special characters,
        <tt>\$</tt> is a regular expression that matches only "$",
        and "\[" is a regular expression that matches only "[", and
        so on.</p>
      </dd>
    </dl>
    You can find a more comprehensive introduction to regular
    expressions in the manual page: <b>man 7 regex</b> 

    <h3><a name="Formal description">Formal description</a></h3>
    From the URE README:<br>
<pre>
This is a simple regular expression package for matching
against Unicode text in UCS2 form. The implementation of this
URE package is a variation on the RE-&gt;DFA algorithm done by
Mark Hopkins (markh@csd4.csd.uwm.edu). Mark Hopkins' algorithm
had the virtue of being very simple, so it was used as a model.

Assumptions:

  o  Regular expression and text already normalized.

  o  Conversion to lower case assumes a 1-1 mapping.

Definitions:

  Separator - any one of U+2028, U+2029, '\n', '\r'.

Operators:
  .   - match any character.
  *   - match zero or more of the last subexpression.
  +   - match one or more of the last subexpression.
  ?   - match zero or one of the last subexpression.
  ()  - subexpression grouping.

  Notes:

    o  The "." operator normally does not match separators, but a flag is
       available for the ure_exec() function that will allow this operator to
       match a separator.

Literals and Constants:

  c       - literal UCS2 character.
  \x....  - hexadecimal number of up to 4 digits.
  \X....  - hexadecimal number of up to 4 digits.
  \u....  - hexadecimal number of up to 4 digits.
  \U....  - hexadecimal number of up to 4 digits.

Character classes:

  [...]           - Character class.
  [^...]          - Negated character class.
  \pN1,N2,...,Nn  - Character properties class.
  \PN1,N2,...,Nn  - Negated character properties class.

  POSIX character classes recognized:

    :alnum:
    :alpha:
    :cntrl:
    :digit:
    :graph:
    :lower:
    :print:
    :punct:
    :space:
    :upper:
    :xdigit:

  And a Unicode specific character class:
    :title:

Aliases
  #url# -&gt; Any internet address (http://www.nowhe.re). Expands to
    "https?://([:alnum:]|[-~./?%_=+])+"
  #email# -&gt; Email address (somebody@somebody.sth). Expands to
    "([:alnum:]|[-~.])+@([:alnum:]|[-~.])+"

  Notes:

    o  Character property classes are \p or \P followed by a comma separated
       list of integers between 1 and 32.  These integers are references to
       the following character properties:

        N   Character Property
        --------------------------
    1   _URE_ALNUM
    2   _URE_ALPHA
    3   _URE_CNTRL
    4   _URE_DIGIT
    5   _URE_GRAPH
    6   _URE_LOWER
    7   _URE_PRINT
    8   _URE_PUNCT
    9   _URE_SPACE
    10  _URE_UPPER
    11  _URE_XDIGIT
    12  _URE_TITLE
    13  _URE_DEFINED
    14  _URE_WIDE
    15  _URE_NONSPACING

    o  Character classes can contain literals, constants, and character
       property classes. Example:

       [abc\U10A\p1,3,4]
</pre>
  </body>
</html>


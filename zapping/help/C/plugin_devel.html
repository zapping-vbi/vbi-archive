<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>

<HEAD>
<META name="GENERATOR" content="Bluefish 0.3.6 + Emacs">
<TITLE>Plugin writer's help</TITLE>
</HEAD>
<BODY BGCOLOR="#fffefe">
<a name="start"></a>
<center><H1>Zapping plugin writer's help<br>(Plugin Protocol 2)</H1></center>
<H2>Brief</H2>
This document explains what are Zapping plugins and how to write one, please read it carefully and mail <A HREF="mailto:garetxe@users.sourceforge.net">me</A> if you have suggestions or you find anything erroneous.
<H2>How does Zapping understand plugins</H2>
On startup, Zapping will scan some directories, and it will try to
load all the files in the directory <STRONG>ending</STRONG> in the
<EM>.zapping.so</EM>. Thus, Zapping will not
try to load <EM>plugin.zapping.so.2</EM>, to put
an example.<br>
After finding the files, it will try to load and validate them. See <A
HREF="#Structure">the plugin structure section</A> to find out what
are the requirements for a plugin to be valid.
<BR>After that, the plugins will become part of Zapping itself, and
you will be able to manage them from inside Zapping.
<BR>The following directories are scanned on startup for plugins:<BR><OL>
	<LI><I><B>$(prefix)</B>/share/zapping/plugins</I>, where
	<B>$(prefix)</B> is the subdirectory were the program will be
	installed, usually <I>/usr</I> or <I>/usr/local</I>.
	<LI><I><B>$HOME</B>/.zapping/plugins</I>, where <B>$HOME</B>
	is the content of the enviromental variable with that name.
	<LI>Anything listed in
	<I><B>$HOME</B>/.zapping/plugin_dirs</I>, if that file
	exists.
</OL>
If there are two or more plugins with the same canonical name, the one
with the highest version is loaded.<p>
<A NAME="Structure"></A>
<H2>Plugin structure in detail</H2>
Every plugin must have a number of functions. Most of them are
optative, and if they aren't present in the plugin, Zapping just
ignores them and uses the defaults. The rest are pretty easy to
implement, and should be just cut'n'paste from the screenshot plugin
(the example plugin that comes with Zapping).<br>
All the functions are prefixed 'zp_' (Zapping Plugin) to avoid symbol
duplication.<br>
There are some compulsory functions that every plugin must have to be
valid, and they must have the following prototypes:<P>
<A NAME="zp_protocol"></A>
<B>gint zp_protocol(void);</B><P>
It must return the protocol number the plugin speaks. 2 in this
revision (the Protocol 1 was used in the 0.3 Zapping series, but it
had serious limitations). If that doesn't match the protocol Zapping
understands, the plugin will not be loaded.<P>
<A NAME="zp_init"></A>
<B>gboolean zp_init ( <A HREF="#PluginBridge">PluginBridge</A>
bridge, tveng_device_info * info );</B><P>
Inits the plugin. It should prepare itself for work, but it shouldn't
start working yet. For that, it should wait until <a
href="#zp_start">zp_start</a> is called.<p>
<I>bridge</I>: The brige is used to let the plugin access Zapping
internals, more on this in the <a href="#Communication">communication
section</a>.<br>
<I>info</I>: A pointer to the structure attached to the video
device. There is no documentation on TVeng yet, see src/tveng.h on the
main Zapping distribution to get some help on this.<br>
<I>Returns</I>: The plugin should return FALSE if it cannot init
itself, so Zapping doesn't try to use it again. TRUE if it can be used.<p>
<A NAME="zp_close"></A>
<B>void zp_close ( void );</B><p>
Close (unload) the plugin. The plugin should free here all the mem it
uses, close file descriptors, kill threads, etc.<p>
<A NAME="zp_start"></A>
<B>gboolean zp_start ( void );</B><p>
When this function is called, the plugin should start to work. It
should return FALSE and stop itself if there is some error, although
it shouldn't be. Anything that could potentially cause errors should
be done in <a href="#zp_init">zp_init</a>.<br>
<I>Returns</I>: TRUE if everything succeeded and FALSE otherwise.<p>
<A NAME="zp_stop"></A>
<B>void zp_stop ( void );</B><p>
Used to stop the plugin, but it shouldn't unload itself.<p>
<A NAME="zp_load_config"></A>
<B>void zp_load_config ( gchar * root_key );</B><p>
The plugins should store their configuration through the ZConf system (look
in the <a href="#AlwaysResolving">functions that always resolve</a>
section to find out how to use ZConf functionalities, but you can
always cut'n'paste from the plugins that come with Zapping). When this
is called, the plugin should read its
values from the zconf config tree, under the given branch.<br>
<B>Note</B>: At least the <I>autostart (Boolean)</I> configuration value
should be present for all plugins. If, when reading the configuration,
the plugin gets a value of <I>TRUE</I> for the <I>autostart</I> value, it
should call <a href="#zp_start">zp_start</a> when <a
href="#zp_init">zp_init</a> is called.<br>
<I>root_key</I>: It will be something like:
<I>/zapping/plugins/plugin_name/</I>, g_strconcat () to this the name
of the key you want to save to build the path zconf functions will be
given.<p>
<A NAME="zp_save_config"></A>
<B>void zp_save_config ( gchar * root_key );</B><p>
This is called when Zapping wants all the plugins to store their
config. The <I>autostart (Boolean)</I> value is compulsory for all
plugins. Zconf should be used here, too.<br>
<I>root_key</I>: The branch of the config tree were the config should
be saved under. It will look like
<I>/zapping/plugins/plugin_name/</I>.<p>
<A NAME="zp_get_info"></A>
<B>void zp_get_info ( gchar ** canonical_name, gchar **
descriptive_name, gchar ** description, gchar ** short_description,
gchar ** author, gchar ** version );</B><p>
Asks the plugin for some info. One or more of the pointers could be
NULL, that will mean that Zapping doesn't need that value. The others should
be modified to point to a valid (possibly statically allocated,
Zapping will not modify or free it) string with the desired
contents.<br>
<I>canonical_name</I>: Short, unique, alphanumeric name for the
plugin. Will be used when creating the config key.<br>
<I>descriptive_name</I>: Long name for the plugin. The user will see
it called like this.<br>
<I>description</I>: Plugin description. Here you should explain what
the plugin does, requirements, and maybe a short faq.<br>
<I>short_description</I>: A line of two giving a general idea of what
the plugin does.<br>
<I>author</I>: Your name here.<br>
<I>version</I>: A string describing the version of the plugin.<p>
<a name="zp_running"></a>
<b>gboolean zp_running ( void );</b><p>
Used by Zapping to know whether the plugin is working or not.<br>
<i>Returns</i>: TRUE if the plugin is working, FALSE otherwise.<p>
<H2>Optative functions</H2>
There are some functions that the plugin may or may not have. If they
aren't present, Zapping doesn't worry, and ignores it.<p>
<a name="zp_process_frame"></a>
<B>gpointer zp_process_frame ( gpointer data, struct tveng_frame_format
* format );</B><p>
This is called for all the plugins secuentially. Here the plugin, if
it is a image processing plugin, would make any changes to the
image.<br>
<I>data</I>: Pointer to the buffer that contains the captured image.<br>
<I>format</I>: A pointer to the struct that holds the image
format. If the plugin modifies the image in size, the
changes should be reflected here, so the following plugins know about
the change and behave correctly. <b>Note</b>: The depth of the image
should not be modified by the plugins.<br>
<I>Returns</I>: A pointer to the new image. Might be the same as the
given pointer.<p>
<a name="zp_get_public_info"></a>
<b>gboolean zp_get_public_info ( gint index, gpointer * ptr,
gchar ** symbol, gchar ** description, gchar ** type, gint * hash );</b><p> 
If present, Zapping will use this routine to get info about the public
symbols in the plugin. This public symbols are the routines or
variables that can be accessed by other plugins. Zapping will call
this from index=0, until gets a return value of FALSE. The plugin must
check if any of the given pointers is NULL, and ignore it if that
happens. The stored pointers, if any, will not be modified or freed by
Zapping.<br>
<I>index</I>: The symbol index we are querying.<br>
<I>ptr</I>: On success, it must contain a pointer to the symbol.<br>
<I>symbol</I>: The symbol name.<br>
<I>description</I>: A short description for this symbol.<br>
<I>type</I>: The type of the symbol, in C
sintax. <b><i>Example</i></b>: int symbol_name (int param1, int
param2);<br>
<I>hash</I>: The hash value for this symbol. More on this in the <a
href="#Communication">communications section</a>.<br>
<I>Returns</I>: The plugin should return TRUE if there is an entry for
index, and FALSE otherwise.<p>
<a name="zp_add_properties"></a>
<b>void zp_add_properties ( GnomePropertyBox * gpb );</b><p>
Tells the plugin that a new property box has been created. Any plugin
that wants to be user-configurable should add a new page to the
property box, and configure the callbacks properly.<br>
<I>gpb</I>:The property box we are building.<p>
<a name="zp_activate_properties"></a>
<b>gboolean zp_activate_properties ( GnomePropertyBox * gpb, gint
page );</b><p>
This is called when the Apply or the OK button are pressed.<br>
<I>gpb</I>: A pointer to the GnomePropertyBox.<br>
<I>page</I>: The active page in the property box. If it is not the
page of the plugin, it should ignore this and return FALSE.<br>
<I>Returns</I>: The plugin should return TRUE if it handles this page,
or FALSE if it doesn't.<p>
<a name="zp_help_properties"></a>
<b>gboolean zp_help_properties ( GnomePropertyBox * gpb, int page
);</b><p>
This is called when the Help button of the property box is
pressed.<br>
<I>gpb</I>: A pointer to the GnomePropertyBox.<br>
<I>page</I>: The active page in the property box. If it is not the
page of the plugin, it should ignore this and return FALSE.<br>
<I>Returns</I>: The plugin should return TRUE if it has built this
page, it doesn't matter whether it does show some help or not. FALSE
on error.<p>
<b>Note</b>: Zapping will only load these three functions
(zp_[add/activate/help]_properties) if the three of them exist,
otherwise, none of them will be loaded, even if one or two of them exist.<p>
<a name="zp_add_gui"></a>
<b>void zp_add_gui ( GnomeApp * app);</b><p>
Tells the plugin that it can add itself to the main Zapping
window.<br>
<I>app</I>: The Gnome Application window belonging to Zapping.<p>
<a name="zp_remove_gui"></a>
<b>void zp_remove_gui ( GnomeApp * app );</b><p>
Asks the plugin to remove all the GUI items it has added to the main
Zapping window. The plugin should call this itself when it is being
closed.<br>
<I>app</I>: The main Zapping window.<p>
<b>Note</b>: Again, zp_[add/remove]_gui go in a bunch. If the two
of them exist, they will be loaded, but if only one exists, it won't
be loaded.<p>
<a name="zp_get_priority"></a>
<b>gint zp_get_priority ( void );</b><p>
This routine lets Zapping know in which order should it run the
plugins.<br>
<I>Returns</I>: The greater this value is, the sooner this plugin will
be run. Thus, a plugin that wants to receive a fully processed image
(such as the screenshot saver) will return a negative value. By
convention, 0 means don't care about the order. If this routine
doesn't exist, 0 is assumed for the plugin priority.<p>
<a name="RunningThePlugin"></a>
<H2>The way Zapping runs the plugins</H2>
The way Zapping runs the plugins is, more or less, the following:<br>
<OL>
        <LI><a href="#zp_protocol">zp_protocol (...)</a>
	<LI><a href="#zp_get_info">zp_get_info (...)</a>
	<LI><a href="#zp_load_config">zp_load_config (...)</a>
	<LI><a href="#zp_init">zp_init (...)</a>
	<LI><a href="#zp_add_gui">zp_add_gui (...)</a>
	<LI><a href="#zp_process_frame">zp_process_frame (...)</a> a
	lot of times 
	<LI><a href="#zp_remove_gui">zp_remove_gui (...)</a>
	<LI><a href="#zp_save_config">zp_save_config (...)</a>
	<LI><a href="#zp_close">zp_close (....)</a>
</OL>
Other routines, such as <a
href="#zp_add_properties">zp_add_properties </a> are called
when the user wants to, so there is no predefined order for those.<p>
<a name="Communication"></a>
<H2>Communication between Zapping and the plugins</H2>
The way Zapping uses to access the plugins has been described, but the
other way, how do the plugins access Zapping, has not yet been
covered. This section will try to solve that.<br>
The plugins are provided with a "bridge" on startup. This bridge is a
pointer to a function with the following prototype:<p>
<a name="PluginBridge"></a>
<b>typedef gboolean (*PluginBridge) ( gpointer * ptr, gchar * plugin,
gchar * symbol, gchar * type, gint hash );</b><p>
Through this bridge the plugin can ask Zapping for symbols
in Zapping itself or in other plugins.<br>
<I>ptr</I>: On success, a pointer to the symbol is stored here. On
error its content can be used to get the error (see below).<br>
<I>plugin</I>: The canonical name of the plugin where the symbol is
located. Can be NULL, indicating that the requested symbol is in
Zapping itself.<br>
<I>symbol</I>: The name of the symbol we want to get.<br>
<I>type</I>: The expected type of the symbol in C sintax. Just for
error reporting.<br>
<I>hash</I>: This hash value is used to avoid errors when calling or
using the returned symbols. When the plugin writer creates a public
symbol (see <a
href="#zp_get_public_info">zp_get_public_info</a>), a random
hash value is given to the symbol. This random value is kept while the
plugin type is the same as the original, but it is changed if its type
changes. This ensures that the real type of the symbol is the same as the
type the plugin believes it is.<br>
<I>Returns</I>: FALSE if the symbol could not be loaded or found, and
TRUE if the location stored at ptr is valid. In case of error, the
meaning of <i>ptr</i> is the following:<br>
<UL>
<LI> <i>0x1</i> means that the requested plugin hasn't been found.
<LI> <i>0x2</i> means that the symbol could not be found in the module.
<LI> <i>0x3</i> means that the symbol was found, but the given hash
is not valid.
</UL><p>
<a name="AlwaysResolving"></a>
<H2>Some functions that always resolve</H2>
There are some functions that will always resolve for Zapping, you can
safely rely on them when writing your plugin, you don't need to use
the provided <a href="PluginBridge">plugin bridge</a> to get them:
<UL>
	<LI>zconf_[get/set/create]_[boolean/string/integer/float];
	(...)
	<LI>GtkWidget * lookup_widget(GtkWidget * node, gchar * name);
	<LI>ShowBox(...);
	<LI>All the tveng functions.
</UL>
<b>Note</b>: You do not need to include any header file apart from
plugin_common.h
<p>
<H2>Epilog</H2>
This is the first version of this document, it may contain errors,
unaccuracies, vague references, typos and gramatical errors (I am not
a native speaker). If you find any of those, please contact me, so it
can get fixed. If you think something is worth adding, if you have any
good ideas for this API, comments or criticism, contact me too. Thanks
a lot.
<P>(C) <A HREF="mailto:garetxe@users.sourceforge.net">Iñaki García
Etxebarria</A> 2000. This document is under the Gnu Documentation License.
</BODY>
</HTML>
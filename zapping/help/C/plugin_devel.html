<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>Plugin writer's help</title>
</head>
<body bgcolor="#FFFEFE">
<a NAME="start"></a>
<center>
<h1>
Zapping plugin writer's help<br>
(Plugin Protocol 2)</h1></center>

<h2>
Brief</h2>
This document explains what are Zapping plugins and how to write one, please
read it carefully and mail <a href="mailto:garetxe@users.sourceforge.net">me</a>
if you have suggestions or you find anything erroneous.
<h2>
How does Zapping understand plugins</h2>
On startup, Zapping will scan some directories, and it will try to load
all the files in the directory <b>ending</b> in the
<i>.zapping.so</i>.
Thus, Zapping will not try to load <i>plugin.zapping.so.2</i>, to put an
example.
<br>After finding the files, it will try to load and validate them. See
<a href="#Structure">the plugin structure section</a> to find out what
are the requirements for a plugin to be valid.
<br>After that, the plugins will become part of Zapping itself, and you
will be able to manage them from inside Zapping.
<br>The following directories are scanned on startup for plugins:
<ol>
<li>
<i><b>$(prefix)</b>/share/zapping/plugins</i>, where <b>$(prefix)</b> is
the subdirectory were the program will be installed, usually <i>/usr</i>
or <i>/usr/local</i>.</li>

<li>
<i><b>$HOME</b>/.zapping/plugins</i>, where <b>$HOME</b> is the content
of the enviromental variable with that name.</li>

<li>
Anything listed in <i><b>$HOME</b>/.zapping/plugin_dirs</i>, if that file
exists.</li>
</ol>
If there are two or more plugins with the same canonical name, the one
with the highest version is loaded.
<p><a NAME="Structure"></a>
<h2>
Plugin structure in detail</h2>
When Zapping finds a possible plugin, it tries to resolve the function
<a href="#plugin_get_protocol">plugin_get_protocol</a> in the plugin's
symbol table. Thus, this function cannot be declared static. If it is
found, it is called, and if the returned version matchs the protocol
Zapping uses, then the other compulsory function, <a
href="#plugin_find_public_symbols">plugin_find_public_symbols</a>, is
resolved. If it is found, the plugin is considered valid, and the rest
of functions, which are optative, are queried through
plugin_find_public_symbols.
<br><a NAME="plugin_get_protol"></a>
<b>gint plugin_get_protocol(void);</b>
<p>It must return the protocol number the plugin speaks. 2 in this
revision (the Protocol 1 was used in the 0.3 Zapping series, but it had
serious limitations). If that doesn't match the protocol Zapping understands,
the plugin will not be loaded.<p>
<a name="plugin_find_public_symbols"></a>
<b>gboolean plugin_find_public_symbols</b>
<p><a NAME="zp_init"></a><b>gboolean zp_init ( <a href="#PluginBridge">PluginBridge</a>
bridge, tveng_device_info * info );</b>
<p>&nbsp;Inits the plugin. It should prepare itself for work, but it shouldn't
start working yet. For that, it should wait until <a href="#zp_start">zp_start</a>
is called.
<p><i>bridge</i>: The brige is used to let the plugin access Zapping internals,
more on this in the <a href="#Communication">communication section</a>.
<br><i>info</i>: A pointer to the structure attached to the video device.
There is no documentation on TVeng yet, see src/tveng.h on the main Zapping
distribution to get some help on this.
<br><i>Returns</i>: The plugin should return FALSE if it cannot init itself,
so Zapping doesn't try to use it again. TRUE if it can be used.
<p><a NAME="zp_close"></a><b>void zp_close ( void );</b>
<p>&nbsp;Close (unload) the plugin. The plugin should free here all the
mem it uses, close file descriptors, kill threads, etc.
<p><a NAME="zp_start"></a><b>gboolean zp_start ( void );</b>
<p>&nbsp;When this function is called, the plugin should start to work.
It should return FALSE and stop itself if there is some error, although
it shouldn't be. Anything that could potentially cause errors should be
done in <a href="#zp_init">zp_init</a>.
<br><i>Returns</i>: TRUE if everything succeeded and FALSE otherwise.
<p><a NAME="zp_stop"></a><b>void zp_stop ( void );</b>
<p>&nbsp;Used to stop the plugin, but it shouldn't unload itself.
<p><a NAME="zp_load_config"></a><b>void zp_load_config ( gchar * root_key
);</b>
<p>&nbsp;The plugins should store their configuration through the ZConf
system (look in the <a href="#AlwaysResolving">functions that always resolve</a>
section to find out how to use ZConf functionalities, but you can always
cut'n'paste from the plugins that come with Zapping). When this is called,
the plugin should read its values from the zconf config tree, under the
given branch.
<br><b>Note</b>: At least the <i>autostart (Boolean)</i> configuration
value should be present for all plugins. If, when reading the configuration,
the plugin gets a value of <i>TRUE</i> for the <i>autostart</i> value,
it should call <a href="#zp_start">zp_start</a> when <a href="#zp_init">zp_init</a>
is called.
<br><i>root_key</i>: It will be something like:
<i>/zapping/plugins/plugin_name/</i>,
g_strconcat () to this the name of the key you want to save to build the
path zconf functions will be given.
<p><a NAME="zp_save_config"></a><b>void zp_save_config ( gchar * root_key
);</b>
<p>&nbsp;This is called when Zapping wants all the plugins to store their
config. The <i>autostart (Boolean)</i> value is compulsory for all plugins.
Zconf should be used here, too.
<br><i>root_key</i>: The branch of the config tree were the config should
be saved under. It will look like
<i>/zapping/plugins/plugin_name/</i>.
<p><a NAME="zp_get_info"></a><b>void zp_get_info ( gchar ** canonical_name,
gchar ** descriptive_name, gchar ** description, gchar ** short_description,
gchar ** author, gchar ** version );</b>
<p>&nbsp;Asks the plugin for some info. One or more of the pointers could
be NULL, that will mean that Zapping doesn't need that value. The others
should be modified to point to a valid (possibly statically allocated,
Zapping will not modify or free it) string with the desired contents.
<br><i>canonical_name</i>: Short, unique, alphanumeric name for the plugin.
Will be used when creating the config key.
<br><i>descriptive_name</i>: Long name for the plugin. The user will see
it called like this.
<br><i>description</i>: Plugin description. Here you should explain what
the plugin does, requirements, and maybe a short faq.
<br><i>short_description</i>: A line of two giving a general idea of what
the plugin does.
<br><i>author</i>: Your name here.
<br><i>version</i>: A string describing the version of the plugin.
<p><a NAME="zp_running"></a><b>gboolean zp_running ( void );</b>
<p>&nbsp;Used by Zapping to know whether the plugin is working or not.
<br><i>Returns</i>: TRUE if the plugin is working, FALSE otherwise.
<br>&nbsp;
<br>&nbsp;
<h2>
Optative functions</h2>
There are some functions that the plugin may or may not have. If they aren't
present, Zapping doesn't worry, and ignores it.
<p><a NAME="zp_process_frame"></a><b>GdkImage * zp_process_frame ( GdkImage
* image, gpointer data, struct tveng_frame_format * format );</b>
<p>&nbsp;This is called for all the plugins secuentially. Here the plugin,
if it is a image processing plugin, would make any changes to the image.
<br><i>image</i>: The image that contains the captured frame.
<i>data</i>:
Pointer to the data contained in <i>image</i>.
<br><i>format</i>: A pointer to the struct that holds the image format.
If the plugin modifies the image in size, the changes should be reflected
here, so the following plugins know about the change and behave correctly.
<b>Note</b>: The depth of the image should not be modified by the plugins.
<br><i>Returns</i>: A pointer to the new image. Might be the same as the
given pointer.
<p><a NAME="zp_get_public_info"></a><b>gboolean zp_get_public_info ( gint
index, gpointer * ptr, gchar ** symbol, gchar ** description, gchar **
type, gint * hash );</b>
<p>&nbsp;If present, Zapping will use this routine to get info about the
public symbols in the plugin. This public symbols are the routines or variables
that can be accessed by other plugins. Zapping will call this from index=0,
until gets a return value of FALSE. The plugin must check if any of the
given pointers is NULL, and ignore it if that happens. The stored pointers,
if any, will not be modified or freed by Zapping.
<br><i>index</i>: The symbol index we are querying.
<br><i>ptr</i>: On success, it must contain a pointer to the symbol.
<br><i>symbol</i>: The symbol name.
<br><i>description</i>: A short description for this symbol.
<br><i>type</i>: The type of the symbol, in C sintax. <b><i>Example</i></b>:
int symbol_name (int param1, int param2);
<br><i>hash</i>: The hash value for this symbol. More on this in the <a href="#Communication">communications
section</a>.
<br><i>Returns</i>: The plugin should return TRUE if there is an entry
for index, and FALSE otherwise.
<p><a NAME="zp_add_properties"></a><b>void zp_add_properties ( GnomePropertyBox
* gpb );</b>
<p>&nbsp;Tells the plugin that a new property box has been created. Any
plugin that wants to be user-configurable should add a new page to the
property box, and configure the callbacks properly.
<br><i>gpb</i>:The property box we are building.
<p><a NAME="zp_activate_properties"></a><b>gboolean zp_activate_properties
( GnomePropertyBox * gpb, gint page );</b>
<p>&nbsp;This is called when the Apply or the OK button are pressed.
<br><i>gpb</i>: A pointer to the GnomePropertyBox.
<br><i>page</i>: The active page in the property box. If it is not the
page of the plugin, it should ignore this and return FALSE.
<br><i>Returns</i>: The plugin should return TRUE if it handles this page,
or FALSE if it doesn't.
<p><a NAME="zp_help_properties"></a><b>gboolean zp_help_properties ( GnomePropertyBox
* gpb, int page );</b>
<p>&nbsp;This is called when the Help button of the property box is pressed.
<br><i>gpb</i>: A pointer to the GnomePropertyBox.
<br><i>page</i>: The active page in the property box. If it is not the
page of the plugin, it should ignore this and return FALSE.
<br><i>Returns</i>: The plugin should return TRUE if it has built this
page, it doesn't matter whether it does show some help or not. FALSE on
error.
<p><b>Note</b>: Zapping will only load these three functions (zp_[add/activate/help]_properties)
if the three of them exist, otherwise, none of them will be loaded, even
if one or two of them exist.
<p><a NAME="zp_add_gui"></a><b>void zp_add_gui ( GnomeApp * app);</b>
<p>&nbsp;Tells the plugin that it can add itself to the main Zapping window.
<br><i>app</i>: The Gnome Application window belonging to Zapping.
<p><a NAME="zp_remove_gui"></a><b>void zp_remove_gui ( GnomeApp * app );</b>
<p>&nbsp;Asks the plugin to remove all the GUI items it has added to the
main Zapping window. The plugin should call this itself when it is being
closed.
<br><i>app</i>: The main Zapping window.
<p><b>Note</b>: Again, zp_[add/remove]_gui go in a bunch. If the two of
them exist, they will be loaded, but if only one exists, it won't be loaded.
<p><a NAME="zp_get_priority"></a><b>gint zp_get_priority ( void );</b>
<p>&nbsp;This routine lets Zapping know in which order should it run the
plugins.
<br><i>Returns</i>: The greater this value is, the sooner this plugin will
be run. Thus, a plugin that wants to receive a fully processed image (such
as the screenshot saver) will return a negative value. By convention, 0
means don't care about the order. If this routine doesn't exist, 0 is assumed
for the plugin priority.
<p><a NAME="RunningThePlugin"></a>
<h2>
The way Zapping runs the plugins</h2>
The way Zapping runs the plugins is, more or less, the following:
<ol>
<li>
<a href="#zp_protocol">zp_protocol (...)</a></li>

<li>
<a href="#zp_get_info">zp_get_info (...)</a></li>

<li>
<a href="#zp_load_config">zp_load_config (...)</a></li>

<li>
<a href="#zp_init">zp_init (...)</a></li>

<li>
<a href="#zp_add_gui">zp_add_gui (...)</a></li>

<li>
<a href="#zp_process_frame">zp_process_frame (...)</a> a lot of times</li>

<li>
<a href="#zp_remove_gui">zp_remove_gui (...)</a></li>

<li>
<a href="#zp_save_config">zp_save_config (...)</a></li>

<li>
<a href="#zp_close">zp_close (....)</a></li>
</ol>
Other routines, such as <a href="#zp_add_properties">zp_add_properties
</a>are called when the user wants to, so there is no predefined order
for those.
<p><a NAME="Communication"></a>
<h2>
Communication between Zapping and the plugins</h2>
The way Zapping uses to access the plugins has been described, but the
other way, how do the plugins access Zapping, has not yet been covered.
This section will try to solve that.
<br>The plugins are provided with a "bridge" on startup. This bridge is
a pointer to a function with the following prototype:
<p><a NAME="PluginBridge"></a><b>typedef gboolean (*PluginBridge) ( gpointer
* ptr, gchar * plugin, gchar * symbol, gchar * type, gint hash );</b>
<p>&nbsp;Through this bridge the plugin can ask Zapping for symbols in
Zapping itself or in other plugins.
<br><i>ptr</i>: On success, a pointer to the symbol is stored here. On
error its content can be used to get the error (see below).
<br><i>plugin</i>: The canonical name of the plugin where the symbol is
located. Can be NULL, indicating that the requested symbol is in Zapping
itself.
<br><i>symbol</i>: The name of the symbol we want to get.
<br><i>type</i>: The expected type of the symbol in C sintax. Just for
error reporting.
<br><i>hash</i>: This hash value is used to avoid errors when calling or
using the returned symbols. When the plugin writer creates a public symbol
(see <a href="#zp_get_public_info">zp_get_public_info</a>), a random hash
value is given to the symbol. This random value is kept while the plugin
type is the same as the original, but it is changed if its type changes.
This ensures that the real type of the symbol is the same as the type the
plugin believes it is.
<br><i>Returns</i>: FALSE if the symbol could not be loaded or found, and
TRUE if the location stored at ptr is valid. In case of error, the meaning
of <i>ptr</i> is the following:
<ul>
<li>
<i>0x1</i> means that the requested plugin hasn't been found.</li>

<li>
<i>0x2</i> means that the symbol could not be found in the module.</li>

<li>
<i>0x3</i> means that the symbol was found, but the given hash is not valid.</li>
</ul>
<a NAME="AlwaysResolving"></a>
<h2>
Some functions that always resolve</h2>
There are some functions that will always resolve for Zapping, you can
safely rely on them when writing your plugin, you don't need to use the
provided <a href="PluginBridge">plugin bridge</a> to get them:
<ul>
<li>
zconf_[get/set/create]_[boolean/string/integer/float]; (...)</li>

<li>
GtkWidget * lookup_widget(GtkWidget * node, gchar * name);</li>

<li>
ShowBox(...);</li>

<li>
All the tveng functions.</li>
</ul>
<a name="Notes"></a>
<h2>Some (probably obvious) notes on designing plugins</h2>
<ul>
<li>Use the template plugin that comes with the distribution as a
start point. Most of the things that aren't well explained here should
become clear there.
<li>Declare <b>static</b> as much data and functions as possible,
otherwise the dynamic linker might do some things you don't expect. I
have been bitten by this myself.
<li>Try not to block Zapping when processing a frame. If the process
is going to take long, it's better to start a new thread. The
screenshot saver that comes with the distro does this.
<li>Use i18n for all the GUI items.
</ul>
<h2>
Epilog</h2>
This is the first version of this document, it may contain errors,
unaccuracies,
vague references, typos and gramatical errors (I am not a native speaker).
If you find any of those, please contact me, so it can get fixed. If you
think something is worth adding, if you have any good ideas for this API,
comments or criticism, contact me too. Thanks a lot.
<p>(C) <a href="mailto:garetxe@users.sourceforge.net">I&ntilde;aki
Garc&iacute;a Etxebarria</a> 2000. This document is under the Gnu
Documentation License (who bothers, anyway :)
</body>
</html>
